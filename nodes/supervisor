#!/usr/bin/env python
# -*- coding: UTF-8 -*-


from itertools import imap
from flup.server.fcgi import WSGIServer
import urlparse
from jinja2 import Environment, PackageLoader

import threading
import os
import rospy
from std_msgs.msg import Empty
from std_msgs.msg import Char
import rosnode

from rospkg import RosPack

import threading 
import time

import json

import subprocess

rospy.init_node('freeplay_sandbox_supervisor')

visual_tracking_publisher = rospy.Publisher('sandtray/signals/start_visual_tracking_calibration', Empty, queue_size=1)

from freeplay_sandbox_supervisor.launcher import Launcher
from freeplay_sandbox_supervisor.experiment import Experiment

package = "freeplay_sandbox"

rp = RosPack()


launchers = []
records = {}

nb_purple_faces = 0
nb_yellow_faces = 0
cv_visual_tracking_ended = threading.Condition()

for root, dirs, files in os.walk(rp.get_path(package)):
    for file in files:
        if file.endswith(".launch"):
            rospy.loginfo("Loading launchfile %s" % file)
            launchers.append(Launcher(package, os.path.join(root, file)))


env = Environment(loader=PackageLoader('freeplay_sandbox_supervisor', 'tpl'))
supervisor_tpl = env.get_template('supervisor.tpl')
launcher_tpl = env.get_template('launcher.tpl')

def onpurplefacedetected(msg):
    global nb_purple_faces
    nb_purple_faces = msg.data

def onyellowfacedetected(msg):
    global nb_yellow_faces
    nb_yellow_faces = msg.data

def onvisualtrackingended(msg):
    global visual_tracking_ended

    cv_visual_tracking_ended.acquire()
    cv_visual_tracking_ended.notify()
    cv_visual_tracking_ended.release()

def fixencoding(s):
    return s.encode("utf-8")

def getfreespace(path="/"):
    df = subprocess.Popen(["df", "-h", path], stdout=subprocess.PIPE)
    output = df.communicate()[0]
    device, size, used, available, percent, mountpoint = output.split("\n")[1].split()
    return "available space on hard-drive: %s/%s (%s%%)" % (available, size, 100-int(percent[:-1]))

def getlauncher(name):
    launcher = None
    for l in launchers:
        if l.name == name:
            launcher = l
            break
    return launcher

def process_launch(options):
    launchfile = options["launch"][0]

    launcher = getlauncher(launchfile)
    if launcher is None:
        rospy.logwarn("Attempting to launch inexistant %s" % launchfile)
        return False

    if "start" in options["action"]:
        launcher.start()
    elif "stop" in options["action"]:
        launcher.shutdown()

    return "true" if launcher.isrunning() else "false"

def status(path, options):

    if "action" in options:
        if "start" in options["action"]:
            return process_launch(options)
        elif "stop" in options["action"]:
            return process_launch(options)
        elif "setarg" in options["action"]:
            launcher = getlauncher(options["launch"][0])
            launcher.setarg(options["arg"][0],
                            options.get("value", [None])[0])
            return launcher_tpl.generate(launcher=launcher, showargs=True)
        elif "updatestate" in options["action"]:
            return json.dumps({l.name: l.isrunning() for l in launchers})



    pingable, unpingable = rosnode.rosnode_ping_all()
    return supervisor_tpl.generate(page="status",
                                   path=path,
                                   launchers=launchers,
                                   nodes_ok=pingable, 
                                   nodes_ko=unpingable)

def manage(path, options):

    if "action" in options:
        if "itemstostash" in options["action"]:
            rospy.loginfo("Sending items back to stash")
            rospy.Publisher('signal_sandtray_items_to_stash', Empty, queue_size=1).publish(Empty())
        if "reshuffleitems" in options["action"]:
            rospy.loginfo("Reshuffling items")
            rospy.Publisher('signal_sandtray_shuffle_items', Empty, queue_size=1).publish(Empty())
        if "clearbackground" in options["action"]:
            rospy.loginfo("Clearing background")
            rospy.Publisher('signal_sandtray_clear_drawing', Empty, queue_size=1).publish(Empty())
        if "localisation" in options["action"]:
            rospy.loginfo("Triggering robot localisation")
            rospy.Publisher('signal_sandtray_robot_localising', Empty, queue_size=1).publish(Empty())

    return supervisor_tpl.generate(page="manage",
                                   path=path)

def record(path, options):

    expe = None
    if "recordid" in options:
        expe = records[options["recordid"][0]]

    if "action" in options:
        if "start_sandbox" in options["action"]:
            launcher = getlauncher("interactive_playground")
            launcher.start()

        elif "start_cameras" in options["action"]:
            launcher = getlauncher("dual_sr300")
            launcher.start()

        elif "start_attention_tracking" in options["action"]:
            launcher = getlauncher("dual_attention_tracking")
            launcher.start()


        elif "createrecord" in options["action"]:
            rospy.loginfo("Creating new experiment with given demographics")
            expe = Experiment(options)
            records[repr(expe)] = expe
            rospy.loginfo("Experiment %s created" % expe)
            return json.dumps(repr(expe))

        elif "updatestate" in options["action"]:
            return json.dumps({l.name: l.isrunning() for l in launchers})

        elif "getdetectedfaces" in options["action"]:
            return json.dumps({"yellow": nb_yellow_faces, "purple": nb_purple_faces})


        elif "start_visual_tracking" in options["action"]:
            rospy.loginfo("Starting the visual tracking task")

            launcher = getlauncher("record_visual_tracking")
            launcher.setarg("output_file", os.path.join(expe.path, "visual_tracking.bag"))
            launcher.setarg("duration", "45") # seconds
            launcher.start()

            visual_tracking_publisher.publish(Empty())

            cv_visual_tracking_ended.acquire()
            cv_visual_tracking_ended.wait()
            cv_visual_tracking_ended.release()


            launcher.shutdown()
            rospy.loginfo("Visual tracking task finished")
            return 'true'

        else: 
            rospy.logwarn("record: received unknown action %s" % str(options["action"]))

    return supervisor_tpl.generate(page="records",
                                   path=path,
                                   freespace=getfreespace(),
                                   records=[])

def app(environ, start_response):

    start_response('200 OK', [('Content-Type', 'text/html')])

    path = environ["PATH_INFO"].decode("utf-8")

    options = urlparse.parse_qs(environ["QUERY_STRING"])
    rospy.logdebug("Incoming request. Path: %s; options passed:\n%s" % (path, str(options)))

    if path.endswith("manage"):
        return imap(fixencoding, manage(path,options))
    elif path.endswith("status"):
        return imap(fixencoding, status(path,options))
    else: # root path: /
        return imap(fixencoding, record(path,options))

if __name__ == '__main__': 

    IP="127.0.0.1"
    PORT=8080

    purpleface_subscriber = rospy.Subscriber("/camera_purple/nb_detected_faces", Char, onpurplefacedetected) 
    yellowface_subscriber = rospy.Subscriber("/camera_yellow/nb_detected_faces", Char, onyellowfacedetected) 
    visual_tracking_ended_subscriber = rospy.Subscriber("/sandtray/signals/visual_tracking_calibration_ended", Empty, onvisualtrackingended) 

    rospy.loginfo("Starting the CGI server on %s:%d (you still need a webserver, though!)" % (IP, PORT))

    WSGIServer(app, bindAddress = (IP, PORT)).run()

    for launcher in launchers:
        launcher.shutdown()

    rospy.loginfo("Bye bye.")

